%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

\chapter{基于Uppaal的中断模型}
\label{cha:intr}

\section{Uppaal中的模型组成}
\label{sec:model_combine}	
一套Uppaal模型由以下三部分组成。
\begin{itemize}
	\item \emph{声明}：整个模型系统中共有的声明，可以是变量或函数。在整个
	系统中都可以访问。
	\item \emph{自动机模板}：各类自动机的通用模板，一个模型系统可以有多个
	模板，一个模板在系统中可以对应多个实例。
		\begin{enumerate}[(1)]
			\item \emph{声明}：模板内部的变量或函数，只有本模板的实例可
			以访问。
			\item \emph{位置}：时间自动机的位置，每个位置可以有初始（
			initial），紧急（urgent），关键（committed）。关键位置与紧
			急位置上，模型中的时钟都停止。不同的是，当有自动机在关键位置时，
			在下一个状态迁移必须从某一个关键位置发出。
			\item \emph{变迁}：位置到位置的迁移。变迁包含选择（select）
			、条件（guard）、同步（sync）、更新（update）四个属性。其中，
			同步和更新是同时发生的。
		\end{enumerate}	
	\item \emph{模型声明}：定义组成系统的模板实例。
\end{itemize}

\section{中断基本模型}
\label{sec:basic}
通常，在我们接触到的非实时性电脑环境中，中断的行为就是符合一个中断的基本模型。
其行为模式就是简单的抢占当前线程，在执行结束之后恢复上下文继续执行被抢占的线
程。

\begin{figure}[H]
	\centering
	\input{figure/thread_states}
	\caption{单个线程的状态}
	\label{fig:thread_state}
\end{figure}

单独的的行为，与多线程程序研究中的线程行为十分相似。我们对中断模型的构建就参
考了多线程程序中的线程模型。如图~\ref{fig:thread_state}所示，通常，一个
线程会被刻画为以下三个状态。
\begin{itemize}
	\item \emph{就绪}：线程可以运行但是当前并不占有CPU。
	\item \emph{运行}：线程正在运行。
	\item \emph{阻塞}：线程在等待处理器以外的资源，暂时无法运行。
\end{itemize}
由于绝大部分多线程程序研究的场景中，并不关心线程产生和终止。换言之，线程在这
类应用场景里直接存在，且永不终止。中断研究中，一个通常具有一个从产生到终止的
完整周期。而且，一个中断并非只触发一次，因此一个可能重复多次上述周期。这与传
统的多线程程序研究是不同的。所以针对一个，我们类比线程再加以修改可以得到如图
~\ref{fig:interrupt_state}所示的状态机。每个状态的含义如下。

\begin{figure}[H]
	\centering
	\input{figure/interrupt_states}
	\caption{单个的状态}
	\label{fig:interrupt_state}
\end{figure}

\begin{itemize}
	\item \emph{无中断}：当前中断没有触发。
	\item \emph{就绪}：中断触发但是有优先级更高的中断在执行。
	\item \emph{运行}：正在运行。
	\item \emph{阻塞}：被优先级更高的中断打断。
\end{itemize}

在多线程的场景中，线程之间的切换往往由线程调度器掌管。线程调度器不是硬件，而是
一段代码，负责实现线程的调度算法。时间片轮转，优先级不同的线程之间的抢占，甚至
是线程优先级的动态变化，都由线程调度器实现。一般而言，线程调度器是系统内核的一
重要组成部分。线程调度器工作的基础就是如图~\ref{fig:thread_table}所示的线
程表结构。线程表通常是一个二维的表，由系统所支持的线程优先级数构成表的行，每一
行内是属于该优先级的所有线程。通常情况下，系统中会有一个就绪线程表和一个阻塞线
程表，当前线程不在任何一个表中。所有的线程调度算法其实都是对这个表的调整。

\begin{figure}
	\centering
	\input{figure/thread_table}
	\caption{线程表}
	\label{fig:thread_table}
\end{figure}

相比而言，多中断场景比多线程场景简单许多。通常情况下，一个中断优先级对应一个中
断处理程序。所以，中断处理程序的组织形式也是一个表，但是从二维降到了一维。在大
部分文档中，这个表被称为中断向量表（Interrupt Vector Table）。中断向量表中
的每个表项被称为一个中断向量（Interrupt Vector），指代一个中断处理程序。在
实现时，一个中断向量通常是一个函数指针，指向某个函数，该函数的内容就是中断处理。

\subsection{通用的硬件实现}
\label{subsec:basic_hardware}

\subsection{Uppaal中的基本中断模型}
\label{subsec:basic_uppaal}

\section{带重入的中断模型}
\label{sec:reentrant}

\subsection{重入的硬件实现}
\label{subsec:reentrant_hardware}

\subsection{Uppaal中的重入中断模型}
\label{subsec:reentrant_uppaal}

\section{分段中断模型}
\label{sec:segment}

\subsection{软件的二次实现}
\label{subsec:segment_software}

\subsection{Uppaal中的分段中断模型}
\label{subsec:segment_uppaal}