%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

\chapter{基于Uppaal的中断模型}
\label{cha:intr}

\section{Uppaal中的模型组成}
\label{sec:model_combine}	
一套Uppaal模型由以下三部分组成。
\begin{itemize}
	\item \emph{声明}：整个模型系统中共有的声明，可以是变量或函数。在整个
	系统中都可以访问。
	\item \emph{自动机模板}：各类自动机的通用模板，一个模型系统可以有多个
	模板，一个模板在系统中可以对应多个实例。
		\begin{enumerate}[(1)]
			\item \emph{声明}：模板内部的变量或函数，只有本模板的实例可
			以访问。
			\item \emph{位置}：时间自动机的位置，每个位置可以有初始（
			initial），紧急（urgent），关键（committed）。关键位置与紧
			急位置上，模型中的时钟都停止。不同的是，当有自动机在关键位置时，
			在下一个状态迁移必须从某一个关键位置发出。
			\item \emph{变迁}：位置到位置的迁移。变迁包含选择（select）
			、条件（guard）、同步（sync）、更新（update）四个属性。其中，
			同步和更新是同时发生的。
		\end{enumerate}	
	\item \emph{模型声明}：定义组成系统的模板实例。
\end{itemize}

\section{中断基本模型}
\label{sec:basic}
通常，在我们接触到的非实时性电脑环境中，中断的行为就是符合一个中断的基本模型。
其行为模式就是简单的抢占当前线程，在中断程序执行结束之后恢复上下文继续执行被抢
占的线程。

\begin{figure}[H]
	\centering
	\input{figure/thread_states}
	\caption{单个线程的状态}
	\label{fig:thread_state}
\end{figure}

单独的中断程序的行为，与多线程程序研究中的线程行为十分相似。我们对中断模型的构
建就参考了多线程程序中的线程模型。如图~\ref{fig:thread_state}所示，通常，一个
线程会被刻画为以下三个状态。
\begin{itemize}
	\item \emph{就绪}：线程可以运行但是当前并不占有CPU。
	\item \emph{运行}：线程正在运行。
	\item \emph{阻塞}：线程在等待处理器以外的资源，暂时无法运行。
\end{itemize}
由于绝大部分多线程程序研究的场景中，并不关心线程产生和终止。换言之，线程在这类
应用场景里直接存在，且永不终止。中断研究中，一个中断程序通常具有一个从产生到终
止的完整周期。而且，一个中断并非只触发一次，因此一个中断程序可能重复多次上述周
期。这与传统的多线程程序研究是不同的。所以针对一个中断程序，我们类比线程再加以
修改可以得到如图~\ref{fig:interrupt_state}所示的状态机。每个状态的含义如下。

\begin{figure}[H]
	\centering
	\input{figure/interrupt_states}
	\caption{单个中断程序的状态}
	\label{fig:interrupt_state}
\end{figure}

在多线程的场景中，线程之间的切换往往由线程调度器掌管。线程调度器不是硬件，而是
一段代码，负责实现线程的调度算法。时间片轮转，优先级不同的线程之间的抢占，甚至
是线程优先级的动态变化，都由线程调度器实现。一般而言，线程调度器是系统内核的一
重要组成部分。线程调度器工作的基础就是如图~所示的线程表结构

\begin{itemize}
	\item \emph{无中断}：当前中断没有触发。
	\item \emph{就绪}：中断触发但是有优先级更高的中断在执行。
	\item \emph{运行}：中断程序正在运行。
	\item \emph{阻塞}：中断程序被优先级更高的中断打断。
\end{itemize}

\subsection{通用的硬件实现}
\label{subsec:basic_hardware}

\subsection{Uppaal中的基本中断模型}
\label{subsec:basic_uppaal}

\section{带重入的中断模型}
\label{sec:reentrant}

\subsection{重入的硬件实现}
\label{subsec:reentrant_hardware}

\subsection{Uppaal中的重入中断模型}
\label{subsec:reentrant_uppaal}

\section{分段中断模型}
\label{sec:segment}

\subsection{软件的二次实现}
\label{subsec:segment_software}

\subsection{Uppaal中的分段中断模型}
\label{subsec:segment_uppaal}