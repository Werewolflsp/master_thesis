%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

\chapter{基于Uppaal的中断模型}
\label{cha:intr}

\section{Uppaal中的模型组成}
\label{sec:model_combine}	
一套Uppaal模型由以下三部分组成。
\begin{itemize}
	\item \emph{声明}：整个模型系统中共有的声明，可以是变量或函数。在整个
	系统中都可以访问。
	\item \emph{自动机模板}：各类自动机的通用模板，一个模型系统可以有多个
	模板，一个模板在系统中可以对应多个实例。
		\begin{enumerate}[(1)]
			\item \emph{声明}：模板内部的变量或函数，只有本模板的实例可
			以访问。
			\item \emph{位置}：时间自动机的位置，每个位置可以有初始（
			initial），紧急（urgent），关键（committed）。关键位置与紧
			急位置上，模型中的时钟都停止。不同的是，当有自动机在关键位置时，
			在下一个状态迁移必须从某一个关键位置发出。
			\item \emph{变迁}：位置到位置的迁移。变迁包含选择（select）
			、条件（guard）、同步（sync）、更新（update）四个属性。其中，
			同步和更新是同时发生的。
		\end{enumerate}	
	\item \emph{模型声明}：定义组成系统的模板实例。
\end{itemize}

\section{基本中断模型}
\label{sec:basic}
通常，在我们接触到的非实时性电脑环境中，中断的行为就是符合一个中断的基本模型。其
行为模式就是简单的抢占当前线程，在执行结束之后恢复上下文继续执行被抢占的线程。

\begin{figure}[H]
	\centering
	\input{figure/thread_states}
	\caption{单个线程的状态}
	\label{fig:thread_state}
\end{figure}

中断处理程序的行为，与多线程程序研究中的线程行为十分相似。我们对中断模型的构建就
参考了多线程程序中的线程模型。如图~\ref{fig:thread_state}所示，通常，一个线程
会被刻画为以下三个状态。
\begin{itemize}
	\item \emph{就绪}：线程可以运行但是当前并不占有CPU。
	\item \emph{运行}：线程正在运行。
	\item \emph{阻塞}：线程在等待处理器以外的资源，暂时无法运行。
\end{itemize}
由于绝大部分多线程程序研究的场景中，并不关心线程产生和终止。换言之，线程在这类应
用场景里直接存在，且永不终止。中断研究中，一个通常具有一个从产生到终止的完整周期
。而且，一个中断并非只触发一次，因此一个可能重复多次上述周期。这与传统的多线程程
序研究是不同的。所以针对一个，我们类比线程再加以修改可以得到如图~\ref{fig:interrupt_state}
所示的状态机。每个状态的含义如下。

\begin{figure}[H]
	\centering
	\input{figure/interrupt_states}
	\caption{单个的状态}
	\label{fig:interrupt_state}
\end{figure}

\begin{itemize}
	\item \emph{无中断}：当前中断没有触发。
	\item \emph{就绪}：中断触发但是有优先级更高的中断在执行。
	\item \emph{运行}：正在运行。
	\item \emph{阻塞}：被优先级更高的中断打断。
\end{itemize}

在多线程的场景中，线程之间的切换往往由线程调度器掌管。线程调度器不是硬件，而是一
段代码，负责实现线程的调度算法。时间片轮转，优先级不同的线程之间的抢占，甚至是线
程优先级的动态变化，都由线程调度器实现。一般而言，线程调度器是系统内核的一重要组
成部分。线程调度器工作的基础就是如图~\ref{fig:thread_table}所示的线程表结构。
线程表通常是一个二维的表，由系统所支持的线程优先级数构成表的行，每一行内是属于该
优先级的所有线程。通常情况下，系统中会有一个就绪线程表和一个阻塞线程表，当前线程
不在任何一个表中。所有的线程调度算法其实都是对这个表的调整。

\begin{figure}
	\centering
	\input{figure/thread_table}
	\caption{线程表}
	\label{fig:thread_table}
\end{figure}

相比而言，多中断场景比多线程场景简单许多。通常情况下，一个中断优先级对应一个中断
处理程序。所以，中断处理程序的组织形式也是一个表，但是从二维降到了一维。在大部分
文档中，这个表被称为中断向量表（Interrupt Vector Table）,如图~\ref{fig:interrupt_vector_table}
所示。中断向量表中的每个表项被称为一个中断向量（Interrupt Vector），指代一个中
断处理程序。在实现时，一个中断向量通常是一个函数指针，指向某个函数，该函数的内容
就是中断处理。因此，不同于多线程场景中，一个线程优先级可以对应多个线程，如图~
\ref{fig:thread_table}中所示，一个中断优先级对应最多一个中断。中断优先级是由CPU
或外部中断控制器等硬件决定的，实际使用时可能用不到所有的优先级，因此会有大量的中
断向量表项为空。

\begin{figure}[H]
	\centering
	\input{figure/interrupt_vector_table}
	\caption{中断向量表}
	\label{fig:interrupt_vector_table}
\end{figure}

除了维数降低，中断向量表相比于线程表而言，还有两个不同点。其一，一般而言，中断向
量表在系统初始化完成以后就不再变化。这里的变化指的是已有的中断的优先级变化，即已
有中断在中断向量表中的位置变化。部分操作系统或裸机程序会有在运行时注册或注销中断
的行为，但是从来没有过更改一个现有中断优先级的行为。换言之，在运行时，中断向量表
可以增加或删除表项，但不会更改表项。\footnote{这是一条编程准则。事实上，只要有足
够的权限，更改中断向量表项的操作是被允许的，因而也是可以完成的。只不过大家都不这
么做。}

其二，中断向量表只有一份，包含了所有的中断，不论其当前状态如何。以线程表而言，系
统中可能有两份甚至多份线程表，分别记录不同状态下的线程。除了笼统地将阻塞线程做成
一张线程表，还有一些实现是将请求同一个锁变量的阻塞线程做成一张单独的表。在该实现
下，系统内会同时存在$L+1$张线程表（$L$代表系统中锁的数量），另外还有一个当前线程
不在任何线程表内。

到此，一个最基本的中断模型就形成了。中断处理程序状态机如图~\ref{fig:interrupt_state}
所示，中断间的组织如图~\ref{fig:interrupt_vector_table}所示。

\subsection{通用的硬件实现}
\label{subsec:basic_hardware}

为了更加忠实地构建模型，我们需要了解中断的实现。因为基本中断模型完全是由硬件实现
的，了解硬件实现的细节能帮我们掌握更多细节，这有助于帮助我们针对遇到的问题进行合
适的抽象。另一方面，虽然中断的实现完全依赖硬件，但是各个硬件平台在实现上述基本中
断机制的方法大同小异，因此本节将介绍一种通用的实现。

中断的硬件实现最主要两个部分是的中断控制器和中断向量表。

中断控制器在\ref{sec:intr}节有简要的介绍。无论是CPU内部还是外部的控制器，其控
制逻辑都是类似的。通常，CPU会有一个或多个指示当前各种状态的STATUS寄存器。STATUS
寄存器中有一位表示是否有中断需要处理，我们称其为中断标志位。CPU在每一个指令周期
之后会检查中断标志位是否置位，如果置位，CPU会和中断控制器通信获取中断号，然后保
存当前上下文，程序计数器（PC）加载中断向量表中对应表项所指向的中断处理程序地址，
开始执行中断程序。进入中断处理时，CPU还会修改STATUS寄存器中的其他的位以表示它现
在正在处理中断。相应的，中断控制器上会有寄存器修改指示当前所有的中断的状态。在接
受新的中断触发信号之后，中断控制器内部的判定逻辑会决定该中断是否可以立即抢占CPU，
进而决定是否需要将CPU的STATUS寄存器中的中断标志位置位。

中断向量表简单许多。通常，中断向量表是在内存中一块独立的区域。在许多平台上，这块
区域从0x0000\footnote{这里用16位数只是举例，表示在内存首地址。如果在32位或64位
平台，地址应该写成0x0000 0000和0x0000 0000 0000 0000}开始。因为CPU会根据一个
中断向量号来查找对应表项，因此中断向量表的基地址完全由CPU的硬件实现规定。部分CPU
允许在系统初始化的时候重新选择中断向量表的基地址，其原理就在于在这些CPU寻址中断
处理程序时，中断向量表基地址是从一个内部寄存器中取出，通过特定的汇编语句可以修改
该寄存器的值，这就完成了中断向量表基地址的修改。在硬件上电启动之前，中断向量表里
的表项并未被赋值。上电之后，在初始化时，由软件给中断向量表各个用到的表项填上对应
的值，通常是各中断处理函数的函数指针。

\subsection{Uppaal中的基本中断模型}
\label{subsec:basic_uppaal}

\section{带重入的中断模型}
\label{sec:reentrant}

\subsection{重入的硬件实现}
\label{subsec:reentrant_hardware}

\subsection{Uppaal中的重入中断模型}
\label{subsec:reentrant_uppaal}

\section{分段中断模型}
\label{sec:segment}

\subsection{软件的二次实现}
\label{subsec:segment_software}

\subsection{Uppaal中的分段中断模型}
\label{subsec:segment_uppaal}