%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

\chapter{引言}
%本章介绍中断的概念和现在学术界对中断的研究。就是文献综述。

\section{什么是中断}
中断（Interrupt）是指处理器接收到特殊信号，提示某个事件发生，应当采取对
应措施的情况。发出这样的信号的行为被称作中断请求（Interrupt Request，I
RQ）。这个信号可以是来自外围硬件的异步信号，也可以是由运行在处理器上的软
件发出同步信号。前者被称为硬件中断（Hardware Interrupt），后者则被称为
软件中断（Software Interrupt，常简称为软中断）。

处理器在接收到中断信号以后，通常会保存当前的执行状态，该执行状态被称为上
下文（Context）。上下文的内容视各个硬件平台的不同而有所区别，但是大多包
含程序计数器和程序状态字以及部分通用计算寄存器。之后，处理器会根据中断向
量表的指示跳转到指定代码片段，即当前中断的处理程序。在执行完中断处理程序
之后，处理器会重新加载之前保存的上下文，继续执行之前被打断的程序。进入中
断和退出中断都包含了将保存当前上下文，载入新的上下文的操作。此类操作被称
作为上下文切换（Context Switch）。\footnote{严格意义上的上下文切换并不
要求保存一个完好的上下文，载入另一个完好的上下文，实际情况中经常发生载入
的上下文只有部分内容有意义的情况。或者对原有上下文并未做出妥善保存即另行
载入，相当于舍弃了当前上下文。这在处理器响应中断时尤其多见。}

人们引入中断是为了提高计算机系统的性能。如果没有中断，处理器在接受外部硬
件通信时只能采取轮询方式。例如，处理器向某硬件发出某指令并需求其回复时，
只能采取繁忙等待(Busy-waiting)模式，这样就会浪费许多处理器周期。即使在
软件层面运用多线程技术进行优化，此类轮询操作依然是性能的损失。在引入中断
之后，处理器就可以专注于当前任务，并且可以在需要时候与外部硬件通信，从而
大幅提高运行效率。\footnote{处理器检查中断的原理其实也类似于一个轮询操作。
每个周期，处理器会检查特定的寄存器的某些位来判断是否有中断需要处理。只不
过这个处理相比于外部硬件通信快速得多。}后来被用于CPU外部与内部紧急事件的
处理、机器故障的处理、时间控制等多个方面，并产生通过软件方式进入中断处理
（软中断）的概念。在处理中断时几乎必然会触发两次切换上下文的操作，该操作
会涉及内存访问，因此其耗时在中断处理程序本身比较短的时候也不可忽略。过于
频繁的中断触发也会在一定程度降低系统的性能。

中断系统在硬件实现上可以是一个包含控制线路的独立系统，也可以被集成进存储
器子系统中。对于前者，在IBM个人机上，广泛使用可编程中断控制器（Programmable 
Interrupt Controller，PIC）来负责中断响应和处理。PIC被连接在若干中断请
求设备和处理器的中断引脚之间，从而实现对处理器中断请求线路（多为一针或两
针）的复用。作为另一种中断实现的形式，即存储器子系统实现方式，可以将中断
端口映射到存储器的地址空间，这样对特定存储器地址的访问实际上是中断请求。
一般桌面领域的PC机中，中断控制器一般是集成在处理器内部，\footnote{例如
Intel推出的8086A系列处理器中，集成了Intel 8259系列中断控制器。}而在嵌入
式领域，很多厂商推出的微控制器实现了外置的中断控制器。\footnote{例如
STMicroelectronics推出的STM32F4系列微控制器中，在ARM的CPU外提供了中断
控制器}

\subsection{操作系统中的中断}
在实际应用中，中断的行为并不一直忠实地遵从其硬件实现，操作系统可以在一定
程度上改变中断的行为。在嵌入式操作系统中，出于实时性的考虑，一个中断的运
行时间不应该过长，但是许多中断需要实现的逻辑功能却比较复杂。因此一个通用
的解决方案就是在操作系统中将中断分成两段，前一段在中断触发时立即执行，后
一段则延后执行。后一段代码的执行优先级较低，因此有可能被其他低优先级中断
甚至是普通代码抢先执行。这样，在编写中断代码的时候，将需要立即执行不容延
迟同时运行时间较短的代码放在第一段，其他的对延时不敏感，或者任务繁重，或
者需要和其他线程进行同步交互的代码放在第二段，就能在满足实时性要求的前提
下完成该中断。eCos等许多操作系统尽管实现方式各异，采用的都是分段中断的模
式。\cite{ecos}

\section{中断程序的正确性}
程序的正确性是我们程序分析与验证时首先应该关心的。保证程序正确性的常用手
段分为动态验证和静态验证。

动态验证即我们通常所谓的测试。根据测试范围的不同，我们可将测试分为三类。
\cite{SWEBOK}
\begin{itemize}
	\item 小范围测试：测试一个函数或一个类（单元测试）
	\item 大范围测试：测试一组类，例如
	\begin{enumerate}[(1)]
		\item 模块测试（测试一个模块）
		\item 集成测试（测试多个模块）
		\item 系统测试（测试整个系统）
	\end{enumerate}
	\item 验收测试：验证软件是否满足需求的正式测试
	\begin{enumerate}[(1)]
		\item 功能测试
		\item 非功能测试（性能测试，压力测试等）
	\end{enumerate}		
\end{itemize}
测试一直时软件工程中十分重要也是最常规的验证的手段。在大多数场合，软件测
试成本低，效果显著。在成熟的软件公司或软件开发团队中，都有专门从事测试的
部门或人员。

静态验证指在不运行程序的前提下，对程序进行的验证。有些程序的测试成本太高，
或者测试用例无法覆盖正常运行时的很多情形，即当我们无法测试程序，或者测试
结果局限性太严重时，我们转向静态验证。静态验证的技术发展至今，已经有了很
多不错的结果。例如：
\begin{itemize}
	\item 代码规范检查
	\item 反例检测
	\item 形式化验证
	\begin{enumerate}[(1)]
		\item 模型检测
		\item 定理证明
	\end{enumerate}	
\end{itemize}



